import * as React from 'react';
import { Size, PropertyControls, ControlType, RenderTarget } from 'framer';

function lerp(v0: number, v1: number, t: number): number {
  return v0 * (1 - t) + v1 * t;
}

const style: React.CSSProperties = {
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  height: '100%',
};

// Define type of property
interface Props extends Size {
  sizing: 'content' | 'container';
  overflow: 'show' | 'hide';
  bounce: boolean;
  delay: number;
  rotateStart: number;
  rotateEnd: number;
  scaleStart: number;
  scaleEnd: number;
  opacityStart: number;
  opacityEnd: number;
  positionStart: number;
  positionEnd: number;
  transformOrigin: boolean;
  started: boolean;
  transformOriginXType: '%' | 'px';
  transformOriginXPixels: number;
  transformOriginXPercent: number;
  transformOriginYType: '%' | 'px';
  transformOriginYPixels: number;
  transformOriginYPercent: number;
  duration: number;
  target:
    | 'top'
    | 'left'
    | 'right'
    | 'bottom'
    | 'opacity'
    | 'rotate'
    | 'scale'
    | 'scaleX'
    | 'scaleY';
  trigger: 'mount' | 'tap' | 'hover';
  easing:
    | 'spring'
    | 'linear'
    | 'ease'
    | 'ease-in'
    | 'ease-out'
    | 'ease-in-out'
    | 'ease-in-quad'
    | 'ease-in-cubic'
    | 'ease-in-quart'
    | 'ease-in-quint'
    | 'ease-in-sine'
    | 'ease-in-expo'
    | 'ease-in-circ'
    | 'ease-in-back'
    | 'ease-out-quad'
    | 'ease-out-cubic'
    | 'ease-out-quart'
    | 'ease-out-quint'
    | 'ease-out-sine'
    | 'ease-out-expo'
    | 'ease-out-circ'
    | 'ease-out-back'
    | 'ease-in-out-quad'
    | 'ease-in-out-cubic'
    | 'ease-in-out-quart'
    | 'ease-in-out-quint'
    | 'ease-in-out-sine'
    | 'ease-in-out-expo'
    | 'ease-in-out-circ'
    | 'ease-in-out-back';
}

interface State {
  started: boolean;
}

const cubicMap = {
  'ease-in-quad': 'cubic-bezier(0.550, 0.085, 0.680, 0.530)',
  'ease-in-cubic': 'cubic-bezier(0.550, 0.055, 0.675, 0.190)',
  'ease-in-quart': 'cubic-bezier(0.895, 0.030, 0.685, 0.220)',
  'ease-in-quint': 'cubic-bezier(0.755, 0.050, 0.855, 0.060)',
  'ease-in-sine': 'cubic-bezier(0.470, 0.000, 0.745, 0.715)',
  'ease-in-expo': 'cubic-bezier(0.950, 0.050, 0.795, 0.035)',
  'ease-in-circ': 'cubic-bezier(0.600, 0.040, 0.980, 0.335)',
  'ease-in-back': 'cubic-bezier(0.600, -0.280, 0.735, 0.045)',
  'ease-out-quad': 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',
  'ease-out-cubic': 'cubic-bezier(0.215, 0.610, 0.355, 1.000)',
  'ease-out-quart': 'cubic-bezier(0.165, 0.840, 0.440, 1.000)',
  'ease-out-quint': 'cubic-bezier(0.230, 1.000, 0.320, 1.000)',
  'ease-out-sine': 'cubic-bezier(0.390, 0.575, 0.565, 1.000)',
  'ease-out-expo': 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',
  'ease-out-circ': 'cubic-bezier(0.075, 0.820, 0.165, 1.000)',
  'ease-out-back': 'cubic-bezier(0.175, 0.885, 0.320, 1.275)',
  'ease-in-out-quad': 'cubic-bezier(0.455, 0.030, 0.515, 0.955)',
  'ease-in-out-cubic': 'cubic-bezier(0.645, 0.045, 0.355, 1.000)',
  'ease-in-out-quart': 'cubic-bezier(0.770, 0.000, 0.175, 1.000)',
  'ease-in-out-quint': 'cubic-bezier(0.860, 0.000, 0.070, 1.000)',
  'ease-in-out-sine': 'cubic-bezier(0.445, 0.050, 0.550, 0.950)',
  'ease-in-out-expo': 'cubic-bezier(1.000, 0.000, 0.000, 1.000)',
  'ease-in-out-circ': 'cubic-bezier(0.785, 0.135, 0.150, 0.860)',
  'ease-in-out-back': 'cubic-bezier(0.680, -0.550, 0.265, 1.550)',
};

export class Animate extends React.Component<Props, State> {
  // Set default properties
  static defaultProps = {
    delay: 0,
    duration: 300,
    target: 'scale',
    trigger: 'tap',
    easing: 'ease-out-back',
  };

  // Items shown in property panel
  static propertyControls: PropertyControls = {
    trigger: {
      type: ControlType.Enum,
      options: ['mount', 'tap', 'hover'],
      optionTitles: ['On Mount', 'On Tap', 'On Hover'],
      defaultValue: 'tap',
      title: 'Trigger',
    },

    target: {
      type: ControlType.Enum,
      options: [
        'top',
        'left',
        'right',
        'bottom',
        'opacity',
        'rotate',
        'scale',
        'scaleX',
        'scaleY',
      ],
      optionTitles: [
        'Top',
        'Left',
        'Right',
        'Bottom',
        'Opacity',
        'Rotate',
        'Scale',
        'Scale X',
        'Scale Y',
      ],
      title: 'Animate',
    },
    scaleStart: {
      type: ControlType.Number,
      defaultValue: 0,
      title: 'Start',
      min: 0,
      max: 100,
      step: 0.01,
      hidden: (props: Props) => {
        return !(
          props.target === 'scale' ||
          props.target === 'scaleX' ||
          props.target === 'scaleY'
        );
      },
    },
    scaleEnd: {
      type: ControlType.Number,
      defaultValue: 1,
      title: 'End',
      min: 0,
      max: 100,
      step: 0.01,
      hidden: (props: Props) => {
        return !(
          props.target === 'scale' ||
          props.target === 'scaleX' ||
          props.target === 'scaleY'
        );
      },
    },
    opacityStart: {
      type: ControlType.Number,
      defaultValue: 0,
      title: 'Start',
      min: 0,
      max: 1,
      step: 0.001,
      hidden: (props: Props) => {
        return props.target !== 'opacity';
      },
    },
    opacityEnd: {
      type: ControlType.Number,
      defaultValue: 1,
      title: 'End',
      min: 0,
      max: 1,
      step: 0.001,
      hidden: (props: Props) => {
        return props.target !== 'opacity';
      },
    },
    positionStart: {
      type: ControlType.Number,
      defaultValue: 0,
      title: 'Offset Start',
      min: -10000,
      max: 10000,
      step: 0.5,
      hidden: (props: Props) => {
        return !(
          props.target === 'left' ||
          props.target === 'right' ||
          props.target === 'bottom' ||
          props.target === 'top'
        );
      },
    },
    positionEnd: {
      type: ControlType.Number,
      defaultValue: 0,
      title: 'Offset End',
      min: -10000,
      max: 10000,
      step: 0.5,
      hidden: (props: Props) => {
        return !(
          props.target === 'left' ||
          props.target === 'right' ||
          props.target === 'bottom' ||
          props.target === 'top'
        );
      },
    },

    rotateStart: {
      type: ControlType.Number,
      defaultValue: 0,
      title: 'Start (deg)',
      min: -360,
      max: 360,
      hidden: (props: Props) => {
        return props.target !== 'rotate';
      },
    },
    rotateEnd: {
      type: ControlType.Number,
      defaultValue: 0,
      title: 'End (deg)',
      min: -360,
      max: 360,
      hidden: (props: Props) => {
        return props.target !== 'rotate';
      },
    },
    easing: {
      type: ControlType.Enum,
      options: [
        'linear',
        'ease',
        'ease-in',
        'ease-out',
        'ease-in-out',
        'ease-in-quad',
        'ease-in-cubic',
        'ease-in-quart',
        'ease-in-quint',
        'ease-in-sine',
        'ease-in-expo',
        'ease-in-circ',
        'ease-in-back',
        'ease-out-quad',
        'ease-out-cubic',
        'ease-out-quart',
        'ease-out-quint',
        'ease-out-sine',
        'ease-out-expo',
        'ease-out-circ',
        'ease-out-back',
        'ease-in-out-quad',
        'ease-in-out-cubic',
        'ease-in-out-quart',
        'ease-in-out-quint',
        'ease-in-out-sine',
        'ease-in-out-expo',
        'ease-in-out-circ',
        'ease-in-out-back',
      ],
      optionTitles: [
        'Linear',
        'Ease',
        'Ease In',
        'Ease Out',
        'Ease In Out',
        'Ease In Quad',
        'Ease In Cubic',
        'Ease In Quart',
        'Ease In Quint',
        'Ease In Sine',
        'Ease In Expo',
        'Ease In Circ',
        'Ease In Back',
        'Ease Out Quad',
        'Ease Out Cubic',
        'Ease Out Quart',
        'Ease Out Quint',
        'Ease Out Sine',
        'Ease Out Expo',
        'Ease Out Circ',
        'Ease Out Back',
        'Ease In Out Quad',
        'Ease In Out Cubic',
        'Ease In Out Quart',
        'Ease In Out Quint',
        'Ease In Out Sine',
        'Ease In Out Expo',
        'Ease In Out Circ',
        'Ease In Out Back',
      ],
      title: 'Easing',
    },
    delay: {
      type: ControlType.Number,
      title: 'Delay',
      min: 0,
      max: 5000,
      hidden: (props: Props) => props.easing === 'spring',
    },
    duration: {
      type: ControlType.Number,
      title: 'Duration',
      min: 0,
      max: 5000,
      hidden: (props: Props) => props.easing === 'spring',
    },
    bounce: {
      type: ControlType.Boolean,
      title: 'Bounce',
      defaultValue: false,
      hidden: (props: Props) => {
        return !(props.trigger === 'tap' || props.trigger === 'hover');
      },
    },
    sizing: {
      type: ControlType.SegmentedEnum,
      options: ['content', 'container'],
      optionTitles: ['Content', 'Wrapper'],
      defaultValue: 'container',
      title: 'Sizing',
    },
    overflow: {
      type: ControlType.SegmentedEnum,
      options: ['show', 'hide'],
      optionTitles: ['Show', 'Hide'],
      defaultValue: 'hide',
      title: 'Overflow',
    },

    transformOrigin: {
      type: ControlType.Boolean,
      title: 'Origin',
    },
    transformOriginXType: {
      type: ControlType.SegmentedEnum,
      options: ['%', 'px'],
      optionTitles: ['%', 'px'],
      defaultValue: 'px',
      title: 'Origin X',
      hidden: (props: Props) => {
        return !props.transformOrigin;
      },
    },
    transformOriginXPercent: {
      type: ControlType.Number,
      min: -100,
      max: 200,
      defaultValue: 50,
      title: 'Origin X (%)',
      hidden: (props: Props) => {
        return !props.transformOrigin || !(props.transformOriginXType === '%');
      },
    },
    transformOriginXPixels: {
      type: ControlType.Number,
      min: -5000,
      max: 10000,
      defaultValue: 0,
      title: 'Origin X (px)',
      hidden: (props: Props) => {
        return !props.transformOrigin || !(props.transformOriginXType === 'px');
      },
    },
    transformOriginYType: {
      type: ControlType.SegmentedEnum,
      options: ['%', 'px'],
      optionTitles: ['%', 'px'],
      defaultValue: 'px',
      title: 'Origin Y',
      hidden: (props: Props) => {
        return !props.transformOrigin;
      },
    },
    transformOriginYPercent: {
      type: ControlType.Number,
      min: -100,
      max: 200,
      defaultValue: 50,
      title: 'Origin Y (%)',
      hidden: (props: Props) => {
        return !props.transformOrigin || !(props.transformOriginYType === '%');
      },
    },
    transformOriginYPixels: {
      type: ControlType.Number,
      min: -5000,
      max: 10000,
      defaultValue: 0,
      title: 'Origin Y (px)',
      hidden: (props: Props) => {
        return !props.transformOrigin || !(props.transformOriginYType === 'px');
      },
    },
  };
  myRef: React.RefObject<HTMLDivElement>;

  constructor(props) {
    super(props);
    this.myRef = React.createRef();
    this.state = {
      started: false,
    };
  }

  componentDidMount() {
    if (this.myRef && this.props.trigger === 'mount') {
      window.requestAnimationFrame(() => this.setState({ started: true }));
    }
  }

  onTap() {
    if (this.myRef && this.props.trigger === 'tap') {
      window.requestAnimationFrame(() =>
        this.setState({ started: true }, () => {
          setTimeout(() => {
            if (this.props.bounce) {
              this.setState({
                started: false,
              });
            }
          }, this.props.duration);
        }),
      );
    }
  }

  onHover() {
    if (this.myRef && this.props.trigger === 'hover') {
      window.requestAnimationFrame(() =>
        this.setState({ started: true }, () => {
          setTimeout(() => {
            if (this.props.bounce) {
              this.setState({
                started: false,
              });
            }
          }, this.props.duration);
        }),
      );
    }
  }

  getInitialValuesStyle(width: number, height: number) {
    const animationStyle: React.CSSProperties = {};
    if (this.props.target === 'rotate') {
      animationStyle.transform = `rotate(${this.props.rotateStart}deg)`;
    }
    if (this.props.target === 'top') {
      animationStyle.transform = `translateY(${-height +
        this.props.positionStart}px)`;
    }
    if (this.props.target === 'left') {
      animationStyle.transform = `translateX(${-width +
        this.props.positionStart}px)`;
    }
    if (this.props.target === 'bottom') {
      animationStyle.transform = `translateY(${height -
        this.props.positionStart}px)`;
    }
    if (this.props.target === 'right') {
      animationStyle.transform = `translateX(${width -
        this.props.positionStart}px)`;
    }
    if (this.props.target === 'opacity') {
      animationStyle.opacity = this.props.opacityStart;
    }
    if (this.props.target === 'scale') {
      animationStyle.transform = `scale(${this.props.scaleStart})`;
    }
    if (this.props.target === 'scaleX') {
      animationStyle.transform = `scaleX(${this.props.scaleStart})`;
    }
    if (this.props.target === 'scaleY') {
      animationStyle.transform = `scaleY(${this.props.scaleStart})`;
    }
    return animationStyle;
  }

  getTargetValuesStyle() {
    const animationStyle: React.CSSProperties = {};

    if (this.props.target === 'rotate') {
      animationStyle.transform = `rotate(${this.props.rotateEnd}deg)`;
    }
    if (this.props.target === 'top') {
      animationStyle.transform = `translateY(${this.props.positionEnd}px)`;
    }
    if (this.props.target === 'left') {
      animationStyle.transform = `translateX(${this.props.positionEnd}px)`;
    }
    if (this.props.target === 'bottom') {
      animationStyle.transform = `translateY(${this.props.positionEnd}px)`;
    }
    if (this.props.target === 'right') {
      animationStyle.transform = `translateX(${this.props.positionEnd}px)`;
    }
    if (this.props.target === 'opacity') {
      animationStyle.opacity = this.props.opacityEnd;
    }
    if (this.props.target === 'scale') {
      animationStyle.transform = `scale(${this.props.scaleEnd})`;
    }
    if (this.props.target === 'scaleX') {
      animationStyle.transform = `scaleX(${this.props.scaleEnd})`;
    }
    if (this.props.target === 'scaleY') {
      animationStyle.transform = `scaleY(${this.props.scaleEnd})`;
    }
    return animationStyle;
  }

  getCurrentValuesStyle(width: number, height: number, progress: number) {
    const animationStyle: React.CSSProperties = {};

    if (this.props.target === 'rotate') {
      animationStyle.transform = `rotate(${lerp(
        this.props.rotateStart,
        this.props.rotateEnd,
        progress,
      )}deg)`;
    }
    if (this.props.target === 'top') {
      animationStyle.transform = `translateY(${lerp(
        -height + this.props.positionStart,
        this.props.positionEnd,
        progress,
      )}px)`;
    }
    if (this.props.target === 'left') {
      animationStyle.transform = `translateX(${lerp(
        -width + this.props.positionStart,
        this.props.positionEnd,
        progress,
      )}px)`;
    }
    if (this.props.target === 'bottom') {
      animationStyle.transform = `translateY(${lerp(
        height - this.props.positionStart,
        this.props.positionEnd,
        progress,
      )}px)`;
    }
    if (this.props.target === 'right') {
      animationStyle.transform = `translateX(${lerp(
        width - this.props.positionStart,
        this.props.positionEnd,
        progress,
      )}px)`;
    }
    if (this.props.target === 'opacity') {
      animationStyle.opacity = lerp(
        this.props.opacityStart,
        this.props.opacityEnd,
        progress,
      );
    }
    if (this.props.target === 'scale') {
      animationStyle.transform = `scale(${lerp(
        this.props.scaleStart,
        this.props.scaleEnd,
        progress,
      )})`;
    }
    if (this.props.target === 'scaleX') {
      animationStyle.transform = `scaleX(${lerp(
        this.props.scaleStart,
        this.props.scaleEnd,
        progress,
      )})`;
    }
    if (this.props.target === 'scaleY') {
      animationStyle.transform = `scaleY(${lerp(
        this.props.scaleStart,
        this.props.scaleEnd,
        progress,
      )})`;
    }
    return animationStyle;
  }

  render() {
    if (
      !this.props.children ||
      React.Children.count(this.props.children) === 0
    ) {
      return <Placeholder text="Connect with frame to animate â†’" />;
    }
    const timingFunction = cubicMap[this.props.easing] || this.props.easing;
    // We sure that child is always there
    const { width = 100, height = 100 } =
      this.props.children && React.Children.count(this.props.children)
        ? React.Children.map(this.props.children, child => {
            if (typeof child === 'string' || typeof child === 'number')
              return {};
            return { width: child.props.width, height: child.props.height };
          })[0]
        : {};

    const animationStyle: React.CSSProperties = {
      width,
      height,
      transitionDelay: `${this.props.delay}ms`,
      transformOrigin: this.props.transformOrigin
        ? `${
            this.props.transformOriginXType === 'px'
              ? `${this.props.transformOriginXPixels}px`
              : `${this.props.transformOriginXPercent}%`
          } ${
            this.props.transformOriginYType === 'px'
              ? `${this.props.transformOriginYPixels}px`
              : `${this.props.transformOriginYPercent}%`
          }`
        : 'center',
      transitionDuration: `${this.props.duration}ms`,
      transitionProperty:
        this.props.target === 'opacity' ? 'opacity' : 'transform',
      transitionTimingFunction: timingFunction,
      display: 'flex',
      position: 'relative',
      justifyContent: 'center',
      alignItems: 'center',
    };

    const positionWidth =
      this.props.sizing === 'container' ? this.props.width : width;
    const positionHeight =
      this.props.sizing === 'container' ? this.props.height : height;

    if (
      this.state.started ||
      RenderTarget.current() === RenderTarget.canvas ||
      this.props.started
    ) {
      Object.assign(animationStyle, this.getTargetValuesStyle());
    } else {
      Object.assign(
        animationStyle,
        this.getInitialValuesStyle(positionWidth, positionHeight),
      );
    }
    const isSpring = this.props.easing === 'spring';
    return (
      <SpringValue
        running={this.state.started && isSpring}
        initial={0}
        target={1}
      >
        {progress => (
          <div
            style={{
              ...style,
              overflow: this.props.overflow === 'show' ? 'visible' : 'hidden',
            }}
            onClick={() => this.onTap()}
            onMouseOver={() => this.onHover()}
          >
            <div
              ref={this.myRef}
              style={{
                ...animationStyle,
                ...(isSpring
                  ? this.getCurrentValuesStyle(width, height, progress)
                  : {}),
              }}
            >
              {this.props.children}
            </div>
          </div>
        )}
      </SpringValue>
    );
  }
}

function Placeholder(props: { text: string }) {
  return <div style={placeholder}>{props.text}</div>;
}

const placeholder: React.CSSProperties = {
  width: '100%',
  height: '100%',
  padding: 10,
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  textAlign: 'center',
  backgroundColor: '#8855FF22',
  color: '#8855FF',
};

interface AnimationCallbacks {
  onStart: () => void;
  onComplete: () => void;
  onReverseComplete: () => void;
  onReverse: () => void;
  onUpdate: (value: number) => void;
}

interface AnimationParams {
  threshold: number;
  yoyo?: boolean;
}

interface SpringParams {
  /** Spring Stiffness, in kg / s^2 */
  stiffness: number;
  /** Damping constant, in kg / s */
  damping: number;
  /** Mass, in kg */
  mass: number;
}

type SpringPresetsType = { [key: string]: SpringParams };

function getSpringParams(incomingParams?: Partial<SpringParams>) {
  return {
    stiffness: -30,
    damping: -0.97,
    mass: 0.5,
    ...incomingParams,
  };
}

function getAnimationParams(incomingParams?: Partial<AnimationParams>) {
  return {
    threshold: 0.001,
    yoyo: false,
    ...incomingParams,
  };
}

const SpringPresets: SpringPresetsType = {
  stiffy: {
    stiffness: -200,
    damping: -20,
    mass: 0.5,
  },
  wiggle: {
    stiffness: -90,
    damping: -4,
    mass: 1.5,
  },
  relaxed: {
    stiffness: -30,
    damping: -4,
    mass: 0.5,
  },
};

interface UseSpring extends AnimationCallbacks {
  initial: number;
  target: number;
  springParams: Partial<SpringParams>;
  animationParams: Partial<AnimationParams>;
}

type StartFunction = (startValue?: number, endValue?: number) => void;

interface SpringValueState {
  paused: boolean;
  reverse: boolean;
  running: boolean;
  value: number;
  from: number;
  to: number;
}

interface SpringValueProps extends Partial<UseSpring> {
  delay?: number;
  paused?: boolean;
  running?: boolean;
  springDisabled?: boolean;
  children: (
    value: number,
    start: StartFunction,
    reverse: () => void,
    pause: () => void,
    unpause: () => void,
  ) => React.ReactNode;
}

class SpringValue extends React.Component<SpringValueProps, SpringValueState> {
  constructor(props: SpringValueProps) {
    super(props);
    this.state = {
      paused: false,
      reverse: false,
      running: this.props.running || false,
      value: this.props.initial || 0,
      from: this.props.initial || 0,
      to: this.props.target || 0,
    };
  }

  animationFrameId?: number;
  // TODO types
  parkedSession: any;

  effect() {
    if (this.state.paused) return;
    const {
      springParams,
      animationParams,
      onComplete,
      onStart,
      onUpdate,
      onReverseComplete,
      onReverse,
      springDisabled,
    } = this.props;

    const { mass, stiffness, damping } = getSpringParams(springParams);
    const { threshold, yoyo } = getAnimationParams(animationParams);
    let start: number;

    let session: any = {
      current: this.state.from,
      target: this.state.to,
      mass,
      vx: 0,
    };

    if (this.parkedSession) {
      session = this.parkedSession;
      this.parkedSession = undefined;
    }

    if (this.animationFrameId !== undefined) {
      cancelAnimationFrame(this.animationFrameId);
    }

    const loop = () => {
      const now = Date.now();
      const elapsed = now - start;
      start = now;
      const spring = stiffness * (session.current - session.target);
      const damper = damping * session.vx;
      const ax = (spring + damper) / session.mass;
      session.vx += ax * (elapsed / 1000);
      const current = session.current + session.vx * (elapsed / 1000);
      if (this.state.paused) {
        this.parkedSession = session;
        return;
      }

      if (
        Math.abs(current - session.target) > threshold &&
        this.state.running &&
        !this.state.paused
      ) {
        session.current = current;
        this.setState({ value: current });
        if (onUpdate) Promise.resolve().then(() => onUpdate(current));
        this.animationFrameId = requestAnimationFrame(loop);
      } else {
        this.setState({ value: session.target, running: false });
        if (onUpdate) Promise.resolve().then(() => onUpdate(session.target));
        if (onComplete && !this.state.reverse) {
          Promise.resolve().then(onComplete);
          if (yoyo) {
            Promise.resolve().then(() => {
              this.setState({
                to: this.props.initial!,
                from: this.state.value,
                reverse: true,
                running: true,
              });
            });
          }
        }
        if (onReverseComplete && this.state.reverse)
          Promise.resolve().then(onReverseComplete);
      }
    };

    if (springDisabled) {
      Promise.resolve().then(() => {
        this.setState({
          value: this.props.target!,
          running: false,
        });
      });
      return;
    }

    if (this.state.running) {
      if (this.props.delay) {
        setTimeout(() => {
          start = Date.now();
          loop();
        }, this.props.delay);
      } else {
        start = Date.now();
        loop();
      }
    }
  }

  componentDidMount() {
    this.effect();
  }

  componentWillUnmount() {
    if (this.animationFrameId !== undefined) {
      cancelAnimationFrame(this.animationFrameId);
    }
  }

  componentDidUpdate(prevProps: SpringValueProps, prevState: SpringValueState) {
    if (
      prevProps.target !== this.props.target ||
      prevProps.initial !== this.props.initial ||
      // prevProps.reverse !== this.props.reverse ||
      prevProps.paused !== this.props.paused ||
      prevProps.running !== this.props.running
    ) {
      const to = (typeof this.props.target !== undefined
        ? this.props.target
        : this.state.to) as number;
      const from = (typeof this.props.initial !== undefined
        ? this.props.initial
        : this.state.from) as number;
      const paused = (typeof this.props.paused !== undefined
        ? this.props.paused
        : this.state.paused) as boolean;
      const running = (typeof this.props.running !== undefined
        ? this.props.running
        : this.state.running) as boolean;
      return this.setState({
        to,
        from,
        paused,
        running,
        reverse: this.state.reverse,
        value: this.state.value,
      });
    }
    if (
      prevState.to !== this.state.to ||
      prevState.from !== this.state.from ||
      prevState.reverse !== this.state.reverse ||
      prevState.paused !== this.state.paused ||
      prevState.running !== this.state.running
    ) {
      this.effect();
    }
  }

  render() {
    const start = (startValue?: number, endValue?: number) => {
      if (endValue !== undefined && startValue !== undefined) {
        this.setState({
          from: startValue,
          to: endValue,
          reverse: false,
          running: true,
        });
      } else if (startValue !== undefined) {
        this.setState({
          to: startValue,
          reverse: false,
          running: true,
        });
      } else {
        this.setState({
          reverse: false,
          from: this.state.value,
          to: this.props.target!,
          running: true,
        });
      }
    };

    const reverse = () => {
      this.setState({
        to: this.props.initial!,
        from: this.state.value,
        reverse: true,
        running: true,
      });
    };

    const pause = () => {
      this.setState({
        paused: true,
      });
    };

    const unpause = () => {
      this.setState({
        paused: false,
        running: true,
      });
    };

    return this.props.children(
      this.state.value,
      start,
      reverse,
      pause,
      unpause,
    );
  }
}
