import * as React from 'react';
import {
  Size,
  PropertyControls,
  ControlType,
  RenderTarget,
  RenderEnvironment,
} from 'framer';

const style: React.CSSProperties = {
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  height: '100%',
};

// Define type of property
interface Props extends Size {
  delay: number;
  rotateStart: number;
  rotateEnd: number;
  duration: number;
  target:
    | 'top'
    | 'left'
    | 'right'
    | 'bottom'
    | 'opacity'
    | 'rotate'
    | 'scale'
    | 'scaleX'
    | 'scaleY';
  trigger: 'mount' | 'tap' | 'hover';
  easing:
    | 'linear'
    | 'ease'
    | 'ease-in'
    | 'ease-out'
    | 'ease-in-out'
    | 'ease-in-quad'
    | 'ease-in-cubic'
    | 'ease-in-quart'
    | 'ease-in-quint'
    | 'ease-in-sine'
    | 'ease-in-expo'
    | 'ease-in-circ'
    | 'ease-in-back'
    | 'ease-out-quad'
    | 'ease-out-cubic'
    | 'ease-out-quart'
    | 'ease-out-quint'
    | 'ease-out-sine'
    | 'ease-out-expo'
    | 'ease-out-circ'
    | 'ease-out-back'
    | 'ease-in-out-quad'
    | 'ease-in-out-cubic'
    | 'ease-in-out-quart'
    | 'ease-in-out-quint'
    | 'ease-in-out-sine'
    | 'ease-in-out-expo'
    | 'ease-in-out-circ'
    | 'ease-in-out-back';
}

interface State {
  started: boolean;
}

const cubicMap = {
  'ease-in-quad': 'cubic-bezier(0.550, 0.085, 0.680, 0.530)',
  'ease-in-cubic': 'cubic-bezier(0.550, 0.055, 0.675, 0.190)',
  'ease-in-quart': 'cubic-bezier(0.895, 0.030, 0.685, 0.220)',
  'ease-in-quint': 'cubic-bezier(0.755, 0.050, 0.855, 0.060)',
  'ease-in-sine': 'cubic-bezier(0.470, 0.000, 0.745, 0.715)',
  'ease-in-expo': 'cubic-bezier(0.950, 0.050, 0.795, 0.035)',
  'ease-in-circ': 'cubic-bezier(0.600, 0.040, 0.980, 0.335)',
  'ease-in-back': 'cubic-bezier(0.600, -0.280, 0.735, 0.045)',
  'ease-out-quad': 'cubic-bezier(0.250, 0.460, 0.450, 0.940)',
  'ease-out-cubic': 'cubic-bezier(0.215, 0.610, 0.355, 1.000)',
  'ease-out-quart': 'cubic-bezier(0.165, 0.840, 0.440, 1.000)',
  'ease-out-quint': 'cubic-bezier(0.230, 1.000, 0.320, 1.000)',
  'ease-out-sine': 'cubic-bezier(0.390, 0.575, 0.565, 1.000)',
  'ease-out-expo': 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',
  'ease-out-circ': 'cubic-bezier(0.075, 0.820, 0.165, 1.000)',
  'ease-out-back': 'cubic-bezier(0.175, 0.885, 0.320, 1.275)',
  'ease-in-out-quad': 'cubic-bezier(0.455, 0.030, 0.515, 0.955)',
  'ease-in-out-cubic': 'cubic-bezier(0.645, 0.045, 0.355, 1.000)',
  'ease-in-out-quart': 'cubic-bezier(0.770, 0.000, 0.175, 1.000)',
  'ease-in-out-quint': 'cubic-bezier(0.860, 0.000, 0.070, 1.000)',
  'ease-in-out-sine': 'cubic-bezier(0.445, 0.050, 0.550, 0.950)',
  'ease-in-out-expo': 'cubic-bezier(1.000, 0.000, 0.000, 1.000)',
  'ease-in-out-circ': 'cubic-bezier(0.785, 0.135, 0.150, 0.860)',
  'ease-in-out-back': 'cubic-bezier(0.680, -0.550, 0.265, 1.550)',
};

export class AnimateBasic extends React.Component<Props, State> {
  // Set default properties
  static defaultProps = {
    delay: 0,
    duration: 300,
    target: 'top',
    trigger: 'tap',
    easing: 'ease-out-back',
  };

  // Items shown in property panel
  static propertyControls: PropertyControls = {
    trigger: {
      type: ControlType.Enum,
      options: ['mount', 'tap', 'hover'],
      optionTitles: ['On Mount', 'On Tap', 'On Hover'],
      defaultValue: 'tap',
      title: 'Trigger',
    },

    target: {
      type: ControlType.Enum,
      options: [
        'top',
        'left',
        'right',
        'bottom',
        'opacity',
        'rotate',
        'scale',
        'scaleX',
        'scaleY',
      ],
      optionTitles: [
        'Top',
        'Left',
        'Right',
        'Bottom',
        'Opacity',
        'Rotate',
        'Scale',
        'Scale X',
        'Scale Y',
      ],
      title: 'Animate',
    },

    rotateStart: {
      type: ControlType.Number,
      defaultValue: 0,
      title: 'Start (deg)',
      min: -360,
      max: 360,
      hidden: (props: Props) => {
        return props.target !== 'rotate';
      },
    },
    rotateEnd: {
      type: ControlType.Number,
      defaultValue: 0,
      title: 'End (deg)',
      min: -360,
      max: 360,
      hidden: (props: Props) => {
        return props.target !== 'rotate';
      },
    },
    easing: {
      type: ControlType.Enum,
      options: [
        'linear',
        'ease',
        'ease-in',
        'ease-out',
        'ease-in-out',
        'ease-in-quad',
        'ease-in-cubic',
        'ease-in-quart',
        'ease-in-quint',
        'ease-in-sine',
        'ease-in-expo',
        'ease-in-circ',
        'ease-in-back',
        'ease-out-quad',
        'ease-out-cubic',
        'ease-out-quart',
        'ease-out-quint',
        'ease-out-sine',
        'ease-out-expo',
        'ease-out-circ',
        'ease-out-back',
        'ease-in-out-quad',
        'ease-in-out-cubic',
        'ease-in-out-quart',
        'ease-in-out-quint',
        'ease-in-out-sine',
        'ease-in-out-expo',
        'ease-in-out-circ',
        'ease-in-out-back',
      ],
      title: 'Easing',
    },
    delay: { type: ControlType.Number, title: 'Delay', min: 0, max: 5000 },
    duration: {
      type: ControlType.Number,
      title: 'Duration',
      min: 0,
      max: 5000,
    },
  };
  myRef: React.RefObject<HTMLDivElement>;

  constructor(props) {
    super(props);
    this.myRef = React.createRef();
    this.state = {
      started: false,
    };
  }

  componentDidMount() {
    if (this.myRef && this.props.trigger === 'mount') {
      window.requestAnimationFrame(() => this.setState({ started: true }));
    }
  }

  onTap() {
    if (this.myRef && this.props.trigger === 'tap') {
      window.requestAnimationFrame(() => this.setState({ started: true }));
    }
  }

  onHover() {
    if (this.myRef && this.props.trigger === 'hover') {
      window.requestAnimationFrame(() => this.setState({ started: true }));
    }
  }

  getInitialValuesStyle(width: number, height: number) {
    const animationStyle: React.CSSProperties = {};
    if (this.props.target === 'rotate') {
      animationStyle.transform = `rotate(${this.props.rotateStart}deg)`;
    }
    if (this.props.target === 'top') {
      animationStyle.transform = `translateY(${-height}px)`;
    }
    if (this.props.target === 'left') {
      animationStyle.transform = `translateX(${-width}px)`;
    }
    if (this.props.target === 'bottom') {
      animationStyle.transform = `translateY(${height}px)`;
    }
    if (this.props.target === 'right') {
      animationStyle.transform = `translateX(${width}px)`;
    }
    if (this.props.target === 'opacity') {
      animationStyle.opacity = 0;
    }
    if (this.props.target === 'scale') {
      animationStyle.transform = `scale(0)`;
    }
    if (this.props.target === 'scaleX') {
      animationStyle.transform = `scaleX(0)`;
    }
    if (this.props.target === 'scaleY') {
      animationStyle.transform = `scaleY(0)`;
    }
    return animationStyle;
  }

  getTargetValuesStyle() {
    const animationStyle: React.CSSProperties = {};

    if (this.props.target === 'rotate') {
      animationStyle.transform = `rotate(${this.props.rotateEnd}deg)`;
    }
    if (this.props.target === 'top') {
      animationStyle.transform = `translateY(0)`;
    }
    if (this.props.target === 'left') {
      animationStyle.transform = `translateX(0)`;
    }
    if (this.props.target === 'bottom') {
      animationStyle.transform = `translateY(0)`;
    }
    if (this.props.target === 'right') {
      animationStyle.transform = `translateX(0)`;
    }
    if (this.props.target === 'opacity') {
      animationStyle.opacity = 1;
    }
    if (this.props.target === 'scale') {
      animationStyle.transform = `scale(1)`;
    }
    if (this.props.target === 'scaleX') {
      animationStyle.transform = `scaleX(1)`;
    }
    if (this.props.target === 'scaleY') {
      animationStyle.transform = `scaleY(1)`;
    }
    return animationStyle;
  }

  render() {
    if (
      !this.props.children ||
      React.Children.count(this.props.children) === 0
    ) {
      return <Placeholder text="Connect with a frame to animate â†’" />;
    }
    const timingFunction = cubicMap[this.props.easing] || this.props.easing;
    // We sure that child is always there
    const { width = 100, height = 100 } =
      this.props.children && React.Children.count(this.props.children)
        ? React.Children.map(this.props.children, child => {
            if (typeof child === 'string' || typeof child === 'number')
              return {};
            return { width: child.props.width, height: child.props.height };
          })[0]
        : {};

    const animationStyle: React.CSSProperties = {
      width,
      height,
      transitionDelay: `${this.props.delay}ms`,
      transformOrigin: 'center',
      transitionDuration: `${this.props.duration}ms`,
      transitionProperty:
        this.props.target === 'opacity' ? 'opacity' : 'transform',
      transitionTimingFunction: timingFunction,
      display: 'flex',
      position: 'relative',
      justifyContent: 'center',
      alignItems: 'center',
    };

    const positionWidth = this.props.width;
    const positionHeight = this.props.height;

    if (this.state.started || RenderTarget.current() === RenderTarget.canvas) {
      Object.assign(animationStyle, this.getTargetValuesStyle());
    } else {
      Object.assign(
        animationStyle,
        this.getInitialValuesStyle(positionWidth, positionHeight),
      );
    }

    return (
      <div
        style={{
          ...style,
          overflow: 'hidden',
        }}
        onClick={() => this.onTap()}
        onMouseOver={() => this.onHover()}
      >
        <div ref={this.myRef} style={animationStyle}>
          {this.props.children}
        </div>
      </div>
    );
  }
}

function Placeholder(props: { text: string }) {
  return <div style={placeholder}>{props.text}</div>;
}

const placeholder: React.CSSProperties = {
  width: '100%',
  height: '100%',
  padding: 10,
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  textAlign: 'center',
  backgroundColor: '#8855FF22',
  color: '#8855FF',
};
